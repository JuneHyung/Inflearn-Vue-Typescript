# 12. 점진적인 타입스크립트 적용 방식 3단계 - Vuex 스토어 타입 정의

## 스토어 TS 파일 변환 및 컴포넌트의 타입 추론 문제 소개

```typescript
import Vue from 'vue'
import App from './App.vue'
import router from './routes/index';
import store from './store/index.js';

Vue.config.productionTip = false

new Vue({
  router,
  store,
  render: h => h(App)
}).$mount('#app')

```

여기서 여태까지 router의 타입정의까지 살펴보았고, 이제 store쪽을 살펴보자.

store의 index.js -> ts로 변환.

들어가기전에❗ store에서는 타입시스템에 대한 이해가 좀 더 필요하다.<br/>ts로 바꿧을때 에러가 발생하지 않지만, 가져다 쓸때 어떤문제가 생기는지 살펴보자.

App.vue created에서 store에 접근해보자.

```vue
<template>
...
</template>
<script lang="ts">
    ...
    create(){
        this.$store.state.
    }
...
</script>
```

state까지는 추론을 통해 찾을 수 있지만, 그 뒤로는 추론이 되지않는 것을 볼 수 있다.

```vue
// store/index.ts
...
export default new Vuex.Store({
  strict: process.env.NODE_ENV !== 'production',
  state: {
    news: [],
    ask: [],
    jobs: [],
    user: {},
    item: {},
    list: []
  },
  getters,
  mutations,
  actions
});
```

이처럼 state가 정의 되있지만, 추론이 되지않아 자바스크립트처럼 사용해야하는 경우가 발생한다.



## 스토어의 타입 추론이 안되는 이유 분석

$store를 타고 들어가게 되면 vue.d.ts파일로 가게 된다.

```vue
declare module "vue/types/options" {
  interface ComponentOptions<V extends Vue> {
    store?: Store<any>;
  }
}
      
declare module "vue/types/vue" {
  interface Vue {
    $store: Store<any>;
  }
}
```

this.$store의 타입추론을 보게되면, Vue라고 정의되있는 타입안에서 $store를 확장했다고 보면된다.

Vue내부적으로 여러 속성들의 기본적인 타입을 정의 해놓았다.

interface merging이라고 해서 두번 인터페이스를 쓰게되면 두개의 인터페이스가 합쳐진다.

이거를 declaration merging(선언 병합) 이라고한다.

참고 : [타입스크립트 선언 병합(declaration mergin)](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)



Store를 쫒아 들어가보자.

this.$store는 `Store<any>`로 추론이 되고있다. 저말은 any가 제네릭으로 들어간다는 것이고,

Store를 보면 아래의 S라는 타입에 any가 들어가 관련 된 모든 속성들이 any로 추론되는 것이다.

```vue
export declare class Store<S> {
  constructor(options: StoreOptions<S>);

  readonly state: S;
  readonly getters: any;

  replaceState(state: S): void;

  dispatch: Dispatch;
  commit: Commit;

  subscribe<P extends MutationPayload>(fn: (mutation: P, state: S) => any, options?: SubscribeOptions): () => void;
....
```

그렇기 때문에 state에 any가 들어가 news등 추론이 되지않는다.



## Vuex 타입 정의 방법 안내 - state

`Vue.extend()`방식을 이용해 뷰엑스를 타이핑 하려면 뷰엑스 라이브러리 내부적으로 제공하는 타입을 약간 변형해주어야함.

### Vuex 기본코드

```typescript
// store/index.ts
import Vue from "vue";
import Vuex from "vuex";

Vue.use(Vuex);

const store = {
  state: {
    token: ''
  }
};

export default new Vuex.Store(store);
```



### state정의

```typescript
// store/state.ts
export const state = {
  token: '',
}

export type RootState = typeof state;
```

분리를 따로 안해도되지만 분리하는 것을 추천.

index.ts하나에 다 작성해버리면, 관리가 힘들어지기 때문에 모듈화 추천.

 state.ts에서 선언한 state라는 타입을 RootState라는 타입변수로 선언해주었다.



### mutation 정의

```vue
// store/mutations.ts
import { RootState } from "./state";

// 뮤테이션 타입
export enum MutationTypes {
  SET_TOKEN = "SET_TOKEN",
}

// 뮤테이션 속성 함수
export const mutations = {
  [MutationTypes.SET_TOKEN](state: RootState, token: string) {
    state.token = token;
  },
};

export type Mutations = typeof mutations;
```

뮤테이션 속성 함수의 타입 추론을 위해 뮤테이션 함수의 이름은 모두 enum값으로 선언하고,<br/> 해당 값을 함수의 이름으로 정의 해줌.

state에서 선언한 RootState를 들고와 뮤테이션 속성ㅎ마수의 첫번째 파라미터 타입으로 연결 해주었다.

❗ 정말 간단하게만 들고온 것이니 **참고 링크에서 자세히 확인**하기.

**참고 : [Cracking Vue.js Vuex 타입 정의 문서](https://joshua1988.github.io/vue-camp/ts/vuex.html)**





## state 타입 정의

state를 먼저 정의 -> 컴포넌트에 추론이 되는지 확인 -> mutation추가 -> 확인 ... 방식으로 진행

```vue
import Vue from 'vue';
import Vuex from 'vuex';
import getters from './getters.js';
import mutations from './mutations.js';
import actions from './actions.js';

Vue.use(Vuex);

const store = {
  state: state,
}

export default new Vuex.Store(store);
```

기존 코드를 주석처리하고 새로 작성.<br/>새로 작성하는 store가 우리가 추가할 옵션들이다.

store에 선언된 state를 가져오기위해 state.ts를 생성

기존의 newsItem[]을 구현해보자.

```typescript
// state.ts
import { NewsItem } from "@/api";

const state = {
  news: [] as NewsItem[],
}
type RootState = typeof state;
export {state, RootState }
```

state의 news는 NewsItem을 배열로 가지는 배열.

RootState를 선언해주게 되면 RootState의 타입이 state의 형태로 잡히는 걸 볼 수 있다.

![RootState-type](./readme_images/12_RootState-type.png)

마지막으로 state도 index.ts에서 들고와 사용할 것이기 때문에 export 시켜준다. 



```typescript
// index.ts
...
import {state} from './state';
...
```

index.ts에서 import해 사용 시 `import state from './state';` 이렇게 사용하면 에러가 날것이다.

> Module '"d:/VueStudy/Inflearn-learn-Vue.js-Typescript/vue-news/src/store/state"' has no default export. Did you mean to use 'import { state } from "d:/VueStudy/Inflearn-learn-Vue.js-Typescript/vue-news/src/store/state"' instead?

state.ts에서 default로 export하지 않았는데 default로 export한 것처럼 import했다는 에러.



## 스토어 내부 타입에 state타입 연결

App.vue에서 다시 사용해보면, 아직 연결이 되어있지않다.

컴포넌트에서도 추론될 수 있도록 수정해보자.

### store의 any를 RootState로 변경

node_moduels에 vuex의 vue.d.ts를 보면, $sotre의 타입이 Store<any> 로 되어있는데. 이 any를 RootState로 바꾸면 된다.

변경후 편집기를 재시작하면 타입추론이 되는 것을 볼 수 있다.

❗  ( node_modules를 다른사람들과 공유할 때 문제가 있다고 생각해서 커뮤니티를 찾아봤는데 추후 강의에 문제점이나 해결방법 등 관련 설명이 나온다고 하니 참고)

[Community-about-nodemoudles](https://www.inflearn.com/questions/220459)
