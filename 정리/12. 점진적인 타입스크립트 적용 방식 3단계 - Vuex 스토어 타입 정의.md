# 12. 점진적인 타입스크립트 적용 방식 3단계 - Vuex 스토어 타입 정의

## 스토어 TS 파일 변환 및 컴포넌트의 타입 추론 문제 소개

```typescript
import Vue from 'vue'
import App from './App.vue'
import router from './routes/index';
import store from './store/index.js';

Vue.config.productionTip = false

new Vue({
  router,
  store,
  render: h => h(App)
}).$mount('#app')

```

여기서 여태까지 router의 타입정의까지 살펴보았고, 이제 store쪽을 살펴보자.

store의 index.js -> ts로 변환.

들어가기전에❗ store에서는 타입시스템에 대한 이해가 좀 더 필요하다.<br/>ts로 바꿧을때 에러가 발생하지 않지만, 가져다 쓸때 어떤문제가 생기는지 살펴보자.

App.vue created에서 store에 접근해보자.

```vue
<template>
...
</template>
<script lang="ts">
    ...
    create(){
        this.$store.state.
    }
...
</script>
```

state까지는 추론을 통해 찾을 수 있지만, 그 뒤로는 추론이 되지않는 것을 볼 수 있다.

```vue
// store/index.ts
...
export default new Vuex.Store({
  strict: process.env.NODE_ENV !== 'production',
  state: {
    news: [],
    ask: [],
    jobs: [],
    user: {},
    item: {},
    list: []
  },
  getters,
  mutations,
  actions
});
```

이처럼 state가 정의 되있지만, 추론이 되지않아 자바스크립트처럼 사용해야하는 경우가 발생한다.



## 스토어의 타입 추론이 안되는 이유 분석

$store를 타고 들어가게 되면 vue.d.ts파일로 가게 된다.

```vue
declare module "vue/types/options" {
  interface ComponentOptions<V extends Vue> {
    store?: Store<any>;
  }
}
      
declare module "vue/types/vue" {
  interface Vue {
    $store: Store<any>;
  }
}
```

this.$store의 타입추론을 보게되면, Vue라고 정의되있는 타입안에서 $store를 확장했다고 보면된다.

Vue내부적으로 여러 속성들의 기본적인 타입을 정의 해놓았다.

interface merging이라고 해서 두번 인터페이스를 쓰게되면 두개의 인터페이스가 합쳐진다.

이거를 declaration merging(선언 병합) 이라고한다.

참고 : [타입스크립트 선언 병합(declaration mergin)](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)



Store를 쫒아 들어가보자.

this.$store는 `Store<any>`로 추론이 되고있다. 저말은 any가 제네릭으로 들어간다는 것이고,

Store를 보면 아래의 S라는 타입에 any가 들어가 관련 된 모든 속성들이 any로 추론되는 것이다.

```vue
export declare class Store<S> {
  constructor(options: StoreOptions<S>);

  readonly state: S;
  readonly getters: any;

  replaceState(state: S): void;

  dispatch: Dispatch;
  commit: Commit;

  subscribe<P extends MutationPayload>(fn: (mutation: P, state: S) => any, options?: SubscribeOptions): () => void;
....
```

그렇기 때문에 state에 any가 들어가 news등 추론이 되지않는다.



## Vuex 타입 정의 방법 안내 - state

**❗❗❗ [필독! 뷰엑스 타입 정의 방법](https://joshua1988.github.io/vue-camp/ts/vuex.html)**

**❗ 정말 간단하게만 들고온 것이니 참고 링크에서 자세히 확인하기.**

**간단하게 state, mutations, actions, getters만 먼저 들고온 것이니 처음부터 끝까지 다읽어보기**



`Vue.extend()`방식을 이용해 뷰엑스를 타이핑 하려면 뷰엑스 라이브러리 내부적으로 제공하는 타입을 약간 변형해주어야함.

### Vuex 기본코드

```typescript
// store/index.ts
import Vue from "vue";
import Vuex from "vuex";

Vue.use(Vuex);

const store = {
  state: {
    token: ''
  }
};

export default new Vuex.Store(store);
```



### state정의

```typescript
// store/state.ts
export const state = {
  token: '',
}

export type RootState = typeof state;
```

분리를 따로 안해도되지만 분리하는 것을 추천.

index.ts하나에 다 작성해버리면, 관리가 힘들어지기 때문에 모듈화 추천.

 state.ts에서 선언한 state라는 타입을 RootState라는 타입변수로 선언해주었다.



### mutation 정의

```vue
// store/mutations.ts
import { RootState } from "./state";

// 뮤테이션 타입
export enum MutationTypes {
  SET_TOKEN = "SET_TOKEN",
}

// 뮤테이션 속성 함수
export const mutations = {
  [MutationTypes.SET_TOKEN](state: RootState, token: string) {
    state.token = token;
  },
};

export type Mutations = typeof mutations;
```

뮤테이션 속성 함수의 타입 추론을 위해 뮤테이션 함수의 이름은 모두 enum값으로 선언하고,<br/> 해당 값을 함수의 이름으로 정의 해줌.

state에서 선언한 RootState를 들고와 뮤테이션 속성함수의 첫번째 파라미터 타입으로 연결 해주었다.

**❗ 정말 간단하게만 들고온 것이니 참고 링크에서 자세히 확인하기.**

**참고 : [Cracking Vue.js Vuex 타입 정의 문서](https://joshua1988.github.io/vue-camp/ts/vuex.html)**



### actions 정의

```typescript
// store/actions.ts
import { ActionContext } from "vuex";
import { Mutations } from "./mutations";
import { RootState } from "./state";

export enum ActionTypes {
  FETCH_NEWS = "FETCH_NEWS"
}

interface News {
  title: string;
  id: number;
}

type MyActionContext = {
  commit<K extends keyof Mutations>(
    key: K,
    payload?: Parameters<Mutations[K]>[1]
  ): ReturnType<Mutations[K]>;
} & Omit<ActionContext<RootState, RootState>, "commit">;

export const actions = {
  async [ActionTypes.FETCH_NEWS](context: MyActionContext, payload?: number) {
    const res = await fetch("https://jsonplaceholder.typicode.com/users/1");
    const user: News[] = await res.json();
    return user;
  }
};

export type Actions = typeof actions;
```



### getters 정의

```typescript
// store/getters.ts
import { RootState } from "./state";

export const getters = {
  getToken(state: RootState) {
    return state.token + "!";
  }
};

export type Getters = typeof getters;
 
```







## state 타입 정의

state를 먼저 정의 -> 컴포넌트에 추론이 되는지 확인 -> mutation추가 -> 확인 ... 방식으로 진행

```vue
import Vue from 'vue';
import Vuex from 'vuex';
import getters from './getters.js';
import mutations from './mutations.js';
import actions from './actions.js';

Vue.use(Vuex);

const store = {
  state: state,
}

export default new Vuex.Store(store);
```

기존 코드를 주석처리하고 새로 작성.<br/>새로 작성하는 store가 우리가 추가할 옵션들이다.

store에 선언된 state를 가져오기위해 state.ts를 생성

기존의 newsItem[]을 구현해보자.

```typescript
// state.ts
import { NewsItem } from "@/api";

const state = {
  news: [] as NewsItem[],
}
type RootState = typeof state;
export {state, RootState }
```

state의 news는 NewsItem을 배열로 가지는 배열.

RootState를 선언해주게 되면 RootState의 타입이 state의 형태로 잡히는 걸 볼 수 있다.

![RootState-type](./readme_images/12_RootState-type.png)

마지막으로 state도 index.ts에서 들고와 사용할 것이기 때문에 export 시켜준다. 



```typescript
// index.ts
...
import {state} from './state';
...
```

index.ts에서 import해 사용 시 `import state from './state';` 이렇게 사용하면 에러가 날것이다.

> Module '"d:/VueStudy/Inflearn-learn-Vue.js-Typescript/vue-news/src/store/state"' has no default export. Did you mean to use 'import { state } from "d:/VueStudy/Inflearn-learn-Vue.js-Typescript/vue-news/src/store/state"' instead?

state.ts에서 default로 export하지 않았는데 default로 export한 것처럼 import했다는 에러.



## 스토어 내부 타입에 state타입 연결

App.vue에서 다시 사용해보면, 아직 연결이 되어있지않다.

컴포넌트에서도 추론될 수 있도록 수정해보자.

### store의 any를 RootState로 변경

node_moduels에 vuex의 vue.d.ts를 보면, $sotre의 타입이 Store<any> 로 되어있는데. 이 any를 RootState로 바꾸면 된다.

변경후 편집기를 재시작하면 타입추론이 되는 것을 볼 수 있다.

```typescript
/**
 * Extends interfaces in Vue.js
 */
import { RootState } from "@/store/state";
import Vue, { ComponentOptions } from "vue";
import { Store } from "./index";

declare module "vue/types/options" {
  interface ComponentOptions<V extends Vue> {
    store?: Store<RootState>;
  }
}

declare module "vue/types/vue" {
  interface Vue {
    $store: Store<RootState>;
  }
}
```

❗  ( node_modules를 다른사람들과 공유할 때 문제가 있다고 생각해서 커뮤니티를 찾아봤는데 추후 강의에 문제점이나 해결방법 등 관련 설명이 나온다고 하니 참고)

[Community-about-nodemoudles](https://www.inflearn.com/questions/220459)



## Mutations 타입 정의

store와 동일하게 mutaions.ts로 모듈화를 할 것. 

먼저 index.ts파일에 추가.

```typescript
import Vue from 'vue';
import Vuex, { StoreOptions } from 'vuex';
import {RootState, state} from './state'
// import getters from './getters.js';
// import mutations from './mutations.js';
// import actions from './actions.js';

Vue.use(Vuex);

const store: StoreOptions<RootState> = {
  state: state,
  mutations: mutations
}

export default new Vuex.Store(store);
```

> ❗  **TIP**
>
> typescript를 사용하다보면, mutations를 추가로 작성할 때 mu까지만 쳐도 자동완성 되는 것을 원할 수 있다.
>
> 그때 store에 StoreOptions를 추가하면, mu만쳤을때 mutation이 자동완성 되게 할 수 있다.

기존의 mutations.js를 ts로 변경하고, 기존의 코드를 전부 주석처리.

**mutations함수의 이름들을 전부 enum으로 관리할 것이다.**

```typescript
enum MutationTypes { 
  SET_NEWS = "SET_NEWS"
}
```

MutationTpyes.SET_NEWS를 했을 때 SET_NEWS가 String값으로 들어가게 설정.

SET_NEWS의 state는 RootState로, news는 newsItem의 배열로 정의.

```typescript
import { NewsItem } from "@/api";
import { RootState } from "./state";

enum MutationTypes { 
  SET_NEWS = "SET_NEWS"
}

const mutations = {
  [MutationTypes.SET_NEWS](state:RootState, news:NewsItem[]) {
    state.news = news;
  },
}

export { mutations };
```

**❗ 자동완성을 적극 활용하자.**



마지막으로 mutations에 정의된 내용이 타입으로 정의해야 추론할 수 있다.

```typescript
type Mutations = typeof mutations;
```

![Mutations-type](./readme_images/12_Mutations-type.png)

>  **❗ 주의할점**
>
> Mutations의 s가 빠지게되면 vuex내부에 정의된 mutation타입이 된다.
>
> 햇갈린다면 Mutations 이름을 custom해서 사용.



## 스토어 타입 추론을 위한 타입 파일 작성

mutation타입이 잘 추론되게 중간에 코드를 추가해보자.

store의 타입추론을 시켜주는 코드는 어떻게 작성하는지 문서를 보며 알아보자.

**참고 : [뷰 컴포넌트에서 활용할 수 있도록 뷰엑스 커스텀 타입 정의](https://joshua1988.github.io/vue-camp/ts/vuex.html#뷰-컴포넌트에서-활용할-수-있도록-뷰엑스-커스텀-타입-정의)**

```typescript
// store/types.ts
import { CommitOptions, Store } from "vuex";
import { Mutations } from "./mutations";
import { RootState } from "./state";

type MyMutations = {
  commit<K extends keyof Mutations, P extends Parameters<Mutations[K]>[1]>(
    key: K,
    payload?: P,
    options?: CommitOptions
  ): ReturnType<Mutations[K]>;
};

export type MyStore = Omit<Store<RootState>, "commit"> & MyMutations
```

스토어에 types라는 파일을 만들어 내부코드를 작성해 주어야 한다.<br/>(참고에 있는 코드들을 가져옴)

아무리 vuex에 타입파일을 추론시키게 변경해도 다른 commit이나 dispatch등의 자동완성이나 자동추론이 되게하는 것은 어렵다.



## 스토어 타입 파일 설명 및 스토어 내부 타입 확장

위 코드에 대해 하나씩 알아가보자.

우선 type MyMutations보다는 export쪽을 보자.

```typescript
export type MyStore = Omit<Store<RootState>, "commit"> & MyMutations
```

types.ts에서 내보내는 타입은 MyStore라는 타입이다.

**MyStore는 Omit과 MyMutations의 합집합(&)**

```typescript
// 인터섹션(합집합) 예제
type A = {
	name: string;
}
type B = {
	age: number;
}
type C = A & B;
const person:C ={
	name: 'a',
	age: 10;
}
```



### Omit

(이전 강의 고급타입에서 한번 봤었다.)

특정 타입에서 지정된 속성만 제거한 타입을 정의해줌.

```typescript
const person = {
    name: 'a',
    age: 10,
    skill: 'js',
}
const jo = Omit<person, 'skill'>
// jo = { name: 'a', age: 10}
```



다시 원래 코드를 살펴보자.

```typescript
export type MyStore = Omit<Store<RootState>, "commit"> & MyMutations
```

**`commit만 빼고 전부 들고오겠다.`는 뜻.**

commit을 빼는이유는 commit에 대해서 **프로젝트 레벨에서 재정의** 하는 것이다.

**재정의를 통해 그 부분만 MyMutations로 갈아 끼워 합친다는 뜻**이다.



vue.d.ts에서

Store<RootState>부분을 MyStore로 변경.

`@/store/types` 이부분이 node_moduels에서 제약이 걸려 @가 에러가 날 것이다.<br/>동작엔 문제가 없지만 거슬린다면 상대경로로 변경.

`this.$store.commit()`의 타입이 우리가 정의한 타입이 된 걸 볼 수있다.

`this.$store.commit(MutationTypes.SET_NEWS, )`했을 때 뒤의 payload가 타입추론이 정상적으로 동작하는 걸 볼 수 있다. => 10입력 시 newsitem[]이 아니라 에러 발생.

참고 : <br/>[고급타입](https://github.com/JuneHyung/Inflearn-learn-Typescript/blob/main/정리/실전/17. 고급 타입.md)<br/>[타입스크립트 Omit](https://joshua1988.github.io/ts/usage/utility.html#자주-사용되는-유틸리티-타입-몇-개-알아보기)



## 뮤테이션 타입 설명 마무리 및 actions 타입 정의 안내

type MyMutations에 대해 살펴보자.

```typescript
type MyMutations = {
  commit<K extends keyof Mutations, P extends Parameters<Mutations[K]>[1]>(
    key: K,
    payload?: P,
    options?: CommitOptions
  ): ReturnType<Mutations[K]>;
};
```



지난강의에서 MyStore가 기존 Store에서 commit을 뺀 것과 MyMutations에서 정의한 commit을 합친 것을 볼 수 있었다.

commit의 스팩은 기본 Store의 commit스펙에서  Mutations란 타입을 가지고 추론 할 수 있게 끔 추가적으로 작성되었다. 

**Mutations의 키와 Mutations[K]의 두번째 파라미터(payload)**를 받아 연결해주었다.

```typescript
commit(MutationsTypes.SET_NEWS, )
```

위 처럼 작성 했을 때 SET_NEWS에 해당하는 mutations속성함수의 키값에 따라서 두번째 파라미터의 타입이 같이 추론이 되는 형태.



options의 경우 기본 Vuex에서 제공하는 CommitOptions를.

그리고 ReturnType이라는 유틸리티 타입을 이용해 Mutation의 반환타입까지 리턴하는 것을 볼 수 있다.



actions를 살펴보자.

index.ts에 이전과 동일하게 actions를 추가해두고, actions.js -> actions.ts로 변경.

기존의 코드는 주석처리로 해두자.



문서를 보자.

```typescript
// store/actions.ts
import { ActionContext } from "vuex";
import { Mutations } from "./mutations";
import { RootState } from "./state";

export enum ActionTypes {
  FETCH_NEWS = "FETCH_NEWS"
}

interface News {
  title: string;
  id: number;
}

type MyActionContext = {
  commit<K extends keyof Mutations>(
    key: K,
    payload?: Parameters<Mutations[K]>[1]
  ): ReturnType<Mutations[K]>;
} & Omit<ActionContext<RootState, RootState>, "commit">;

export const actions = {
  async [ActionTypes.FETCH_NEWS](context: MyActionContext, payload?: number) {
    const res = await fetch("https://jsonplaceholder.typicode.com/users/1");
    const user: News[] = await res.json();
    return user;
  }
};

export type Actions = typeof actions;
```

vuex의 ActionContext랑 앞에서 정의했던 Mutations와 RootState를 들고온다.

그리고 mutatinos처럼 Actiontypes를 enum으로 정의.

그리고 actinos를 작성하고, 마지막에 export시켜주는 걸 볼 수 있다.

**참고 : [actions 정의](https://joshua1988.github.io/vue-camp/ts/vuex.html#actions-정의)**
